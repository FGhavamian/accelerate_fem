# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/notebooks/00_abstract_geometry.ipynb (unless otherwise specified).

__all__ = ['generate_random_circle_in_box', 'has_enough_distance_from_circles', 'get_random_circle_radius',
           'AbstractGeometry']

# Cell
from shapely.geometry import Point, box, Polygon, MultiPoint, MultiPolygon, LineString, MultiLineString
from geocube.api.core import make_geocube
import geopandas as gpd
from scipy import stats
import numpy as np
import pickle

# Cell
def generate_random_circle_in_box(box_size, circle_radius, gap):
    """distance from box edge is 2xcircel_radius"""
    center_x = np.random.random() * (box_size[0] - 2*(circle_radius + gap)) + (circle_radius + gap)
    center_y = np.random.random() * (box_size[1] - 2*(circle_radius + gap)) + (circle_radius + gap)

    circle = Point(center_x, center_y).buffer(circle_radius)

    return circle

# Cell
def has_enough_distance_from_circles(circle, other_circles, gap):
    other_circles = MultiPolygon(other_circles)
    """too close is when they are circle_radius closer"""
    return circle.distance(other_circles) > gap

# Cell
def get_random_circle_radius(circle_radius_range):
    return np.random.random()*(circle_radius_range[1] - circle_radius_range[0]) + circle_radius_range[0]

# Cell
class AbstractGeometry:
    def __init__(self, circle_density, circle_radius_range, box_size, gap, seed):
        self.final_box_size = box_size
        self.box_size = [2*d for d in box_size]
        self.circle_radius_range = circle_radius_range
        self.gap = gap
        self.seed = seed

        self.n_circles = self._compute_n_circles(circle_density)

    def get_geom_info(self):
        circles = self._generate_random_circles()
        circles = self._crop_to_final_box_size(circles)
        box_coord_dim = self._get_box_coord_dim()

        return circles, box_coord_dim

    def _compute_n_circles(self, circle_density):
        box_area = self.box_size[0] * self.box_size[1]
        avg_circle_radius = np.sqrt(self.circle_radius_range[0] * self.circle_radius_range[1])
        avg_circle_area = np.pi*avg_circle_radius**2
        effective_box_area = box_area * circle_density
        n_circles = effective_box_area / avg_circle_area
        return n_circles

    def _crop_to_final_box_size(self, circles):
        a0, b0 = self.box_size
        a, b = self.final_box_size

        final_box = Polygon([
            [(a0-a)/2, (b0-b)/2],
            [(a0+a)/2, (b0-b)/2],
            [(a0+a)/2, (b0+b)/2],
            [(a0-a)/2, (b0+b)/2],
            [(a0-a)/2, (b0-b)/2],
        ])

        return circles.intersection(final_box)

    def _get_box_coord_dim(self):
        a0, b0 = self.box_size
        a, b = self.final_box_size

        return [(a0-a)/2, (b0-b)/2, a, b]

    def _generate_random_circles(self):
        np.random.seed(self.seed)

        counter = 0
        attempts = 0

        while counter < self.n_circles:
            circle_radius = get_random_circle_radius(self.circle_radius_range)

            if counter == 0 and attempts == 0:
                circle = generate_random_circle_in_box(
                    self.box_size,
                    circle_radius=circle_radius,
                    gap=self.gap)

                circles = MultiPolygon([circle])

            attempts += 1
            if attempts > 100 * self.n_circles:
                print(f'''[WARNING] {attempts} attempts, reduce circle radius, increase box size, or decrease number of circles
                returning {len(circles)} circles''')
                return circles

            circle = generate_random_circle_in_box(
                self.box_size,
                circle_radius=circle_radius,
                gap=self.gap)

            if has_enough_distance_from_circles(circle, circles, self.gap):

                circles_tmp = MultiPolygon([g for g in circles.geoms] + [circle])
                if circles_tmp.is_valid:
                    circles = circles_tmp
                    counter += 1

        return circles

    def save_at(self, path):
        with open(path, 'wb') as handle:
            pickle.dump(self, handle)