# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/notebooks/03_predict.ipynb (unless otherwise specified).

__all__ = ['timeit', 'Predictor', 'max_per_case']

# Cell
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
import argparse
from time import time
from functools import wraps

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from joblib import Parallel, delayed

import accelerate_simulations.geometry as geom
import accelerate_simulations.preprocess as prep

# Cell
def timeit(func):
    @wraps(func)
    def _time_it(*args, **kwargs):
        start = int(round(time() * 1000))
        try:
            return func(*args, **kwargs)
        finally:
            end_ = int(round(time() * 1000)) - start
            print(f"[INFO]\t\t {func.__name__} took: {end_/1000 if end_ > 0 else 0:.2f} s")
    return _time_it

# Cell
class Predictor:
    def __init__(self, path_model, **config):
        self.config = config
        self.model = self.load_model(path_model)

    def __call__(self, n_samples, circle_radius_range):
        input_fields = self.make_input_fields(n_samples, circle_radius_range)
        pred = self.predict(input_fields)
        return pred

    @staticmethod
    @timeit
    def load_model(path):
        return tf.keras.models.load_model(path)

    @timeit
    def predict(self, input_fields):
        return self.model.predict(input_fields)

    @timeit
    def make_input_fields(self, n_samples, circle_radius_range):
        par = Parallel(n_jobs=-1)
        del_func = delayed(self.make_input_field)

        input_fields = par(
            del_func(
                np.random.randint(1e6),
                circle_radius_range,
                self.config
            )
            for _ in range(n_samples)
        )

        return np.stack(input_fields, axis=0)

    @staticmethod
    def make_input_field(seed, circle_radius_range, config):
        abstract_geometry = geom.AbstractGeometry(
                config['circle_density'],
                circle_radius_range,
                config['box_size'],
                config['gap'],
                seed=seed)

        rasterize = geom.GeometryRasterizer(resolution=config['resolution'])
        x, y, raster_image = rasterize(abstract_geometry)

        make_geometric_fields = prep.GeometricFieldMaker(
            config['names_boundary'],
            geom.element_to_tag,
            scaling_factor=3)

        input_fields = make_geometric_fields(raster_image, x, y)
        return input_fields


# Cell
def max_per_case(pred):
    return np.max(pred*1e+4, axis=(1,2,3))