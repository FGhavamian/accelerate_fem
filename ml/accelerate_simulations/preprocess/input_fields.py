# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/02_input_fields.ipynb (unless otherwise specified).

__all__ = ['MaterialFieldMaker', 'GeometricFieldMaker']

# Cell
import os
import pickle

import numpy as np
from scipy.spatial.distance import cdist

import accelerate_simulations
from ..geometry import GeometryRasterizer, element_to_tag

# Cell
class MaterialFieldMaker:
    def __init__(self, material_properties, element_to_tag):
        self.material_properties = material_properties
        self.element_to_tag = element_to_tag

    def __call__(self, raster_array):
        raster_image = np.array(raster_array.tags)

        material_fields = []
        for _, material_property in self.material_properties.items():
            material_fields.append(
                self._make_field(raster_image, material_property)
            )

        return np.stack(material_fields, axis=-1)

    def _make_field(self, raster_image, material_property):
        material_field = np.zeros_like(raster_image)
        for name, value in material_property.items():
            tag = self.element_to_tag[name]
            cond = (raster_image == tag)
            material_field[cond] = value

        return material_field

# Cell
class GeometricFieldMaker:
    def __init__(self, names_boundary, element_to_tag, scaling_factor):
        self.element_to_tag = element_to_tag
        self.scaling_factor = scaling_factor
        self.names_boundary = self._add_default_boundaries(names_boundary[:]) # [:] so that names_boundary is not over written

    def __call__(self, raster_array):
        raster_image = np.array(raster_array.tags)
        x, y = np.array(raster_array.x), np.array(raster_array.y)
        grid_flat = self._get_grid(x, y)

        geometric_fields = []
        for name in self.names_boundary:
            if name.startswith('default_'):
                grid_flat_some = self._get_grid_default(raster_image, x, y, name)
            else:
                grid_flat_some = self._get_grid_tag(raster_image, x, y, name)

            geometric_field = self._make_geometric_field(grid_flat, grid_flat_some, x, y)
            geometric_fields.append(geometric_field)

        return np.stack(geometric_fields, axis=-1)

    @staticmethod
    def _add_default_boundaries(names_boundary):
        names_default_boundary = ['default_left', 'default_bottom', 'default_right', 'default_top']
        names_boundary += names_default_boundary[:]
        return names_boundary

    def _get_default_grid():
        pass

    @staticmethod
    def _get_grid(x, y):
        grid_x, grid_y = np.meshgrid(x, y)
        grid_flat = np.hstack([grid_x.flatten()[:, None], grid_y.flatten()[:, None]])
        return grid_flat

    def _get_grid_tag(self, raster_image, x, y, name):
        tag = self.element_to_tag[name]
        grid_x, grid_y = np.meshgrid(x, y)

        cond = (raster_image==tag)
        grid_x = grid_x[cond]
        grid_y = grid_y[cond]

        return np.hstack([grid_x.flatten()[:, None], grid_y.flatten()[:, None]])

    def _get_grid_default(self, raster_image, x, y, name: str):
        grid_x, grid_y = np.meshgrid(x, y)

        if name.endswith('left'):     grid_x, grid_y = grid_x[0, :], grid_y[0, :]
        elif name.endswith('bottom'): grid_x, grid_y = grid_x[:, 0], grid_y[:, 0]
        elif name.endswith('right'):  grid_x, grid_y = grid_x[-1, :], grid_y[-1, :]
        elif name.endswith('top'):    grid_x, grid_y = grid_x[:, -1], grid_y[:, -1]

        return np.hstack([grid_x.flatten()[:, None], grid_y.flatten()[:, None]])

    def _dist_radial(self, x):
        return np.exp(-self.scaling_factor * x/(x.max()+1e-8))

    def _make_geometric_field(self, grid_flat, grid_flat_some, x, y):
        dist_point_to_boundary = cdist(grid_flat, grid_flat_some)
        dist_point_to_boundary = np.min(dist_point_to_boundary, axis=1)
        geometric_field = self._dist_radial(dist_point_to_boundary)
        return geometric_field.reshape(len(x), len(y))