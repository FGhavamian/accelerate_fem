# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/notebooks/02_input_fields.ipynb (unless otherwise specified).

__all__ = ['MaterialFieldMaker', 'eucl_opt', 'GeometricFieldMaker']

# Cell
import os
import pickle

import numpy as np
from scipy.spatial.distance import cdist
import numba as nb

import accelerate_simulations
from ..geometry import GeometryRasterizer, element_to_tag

# Cell
class MaterialFieldMaker:
    def __init__(self, material_properties, element_to_tag):
        self.material_properties = material_properties
        self.element_to_tag = element_to_tag

    def __call__(self, raster_image):
        material_fields = []
        for _, material_property in self.material_properties.items():
            material_fields.append(
                self._make_field(raster_image, material_property)
            )

        return np.stack(material_fields, axis=-1)

    def _make_field(self, raster_image, material_property):
        material_field = np.zeros_like(raster_image)
        for name, value in material_property.items():
            tag = self.element_to_tag[name]
            cond = (raster_image == tag)
            material_field[cond] = value

        return material_field

# Cell
@nb.njit(fastmath=True,parallel=True)
def eucl_opt(A, B):
    """https://github.com/numba/numba-scipy/issues/38#issuecomment-623569703"""
    assert A.shape[1]==B.shape[1]
    C=np.empty((A.shape[0],B.shape[0]),A.dtype)
    I_BLK=32
    J_BLK=32

    #workaround to get the right datatype for acc
    init_val_arr=np.zeros(1,A.dtype)
    init_val=init_val_arr[0]

    #Blocking and partial unrolling
    #Beneficial if the second dimension is large -> computationally bound problem
    #
    for ii in nb.prange(A.shape[0]//I_BLK):
        for jj in range(B.shape[0]//J_BLK):
            for i in range(I_BLK//4):
                for j in range(J_BLK//2):
                    acc_0=init_val
                    acc_1=init_val
                    acc_2=init_val
                    acc_3=init_val
                    acc_4=init_val
                    acc_5=init_val
                    acc_6=init_val
                    acc_7=init_val
                    for k in range(A.shape[1]):
                        acc_0+=(A[ii*I_BLK+i*4+0,k] - B[jj*J_BLK+j*2+0,k])**2
                        acc_1+=(A[ii*I_BLK+i*4+0,k] - B[jj*J_BLK+j*2+1,k])**2
                        acc_2+=(A[ii*I_BLK+i*4+1,k] - B[jj*J_BLK+j*2+0,k])**2
                        acc_3+=(A[ii*I_BLK+i*4+1,k] - B[jj*J_BLK+j*2+1,k])**2
                        acc_4+=(A[ii*I_BLK+i*4+2,k] - B[jj*J_BLK+j*2+0,k])**2
                        acc_5+=(A[ii*I_BLK+i*4+2,k] - B[jj*J_BLK+j*2+1,k])**2
                        acc_6+=(A[ii*I_BLK+i*4+3,k] - B[jj*J_BLK+j*2+0,k])**2
                        acc_7+=(A[ii*I_BLK+i*4+3,k] - B[jj*J_BLK+j*2+1,k])**2
                    C[ii*I_BLK+i*4+0,jj*J_BLK+j*2+0]=np.sqrt(acc_0)
                    C[ii*I_BLK+i*4+0,jj*J_BLK+j*2+1]=np.sqrt(acc_1)
                    C[ii*I_BLK+i*4+1,jj*J_BLK+j*2+0]=np.sqrt(acc_2)
                    C[ii*I_BLK+i*4+1,jj*J_BLK+j*2+1]=np.sqrt(acc_3)
                    C[ii*I_BLK+i*4+2,jj*J_BLK+j*2+0]=np.sqrt(acc_4)
                    C[ii*I_BLK+i*4+2,jj*J_BLK+j*2+1]=np.sqrt(acc_5)
                    C[ii*I_BLK+i*4+3,jj*J_BLK+j*2+0]=np.sqrt(acc_6)
                    C[ii*I_BLK+i*4+3,jj*J_BLK+j*2+1]=np.sqrt(acc_7)
        #Remainder j
        for i in range(I_BLK):
            for j in range((B.shape[0]//J_BLK)*J_BLK,B.shape[0]):
                acc_0=init_val
                for k in range(A.shape[1]):
                    acc_0+=(A[ii*I_BLK+i,k] - B[j,k])**2
                C[ii*I_BLK+i,j]=np.sqrt(acc_0)

    #Remainder i
    for i in range((A.shape[0]//I_BLK)*I_BLK,A.shape[0]):
        for j in range(B.shape[0]):
            acc_0=init_val
            for k in range(A.shape[1]):
                acc_0+=(A[i,k] - B[j,k])**2
            C[i,j]=np.sqrt(acc_0)

    return C

# Cell
class GeometricFieldMaker:
    def __init__(self, names_boundary, element_to_tag, scaling_factor, use_gpu=False):
        self.element_to_tag = element_to_tag
        self.scaling_factor = scaling_factor
        self.use_gpu = use_gpu
        self.names_boundary = self._add_default_boundaries(names_boundary[:]) # [:] so that names_boundary is not over written

        if self.use_gpu:
            print('[WARNING] tensorflow could hug gpu memory and do not allow numba to use it')

    def __call__(self, raster_image, x, y):
        grid_flat = self._get_grid(x, y)

        geometric_fields = []
        for name in self.names_boundary:
            if name.startswith('default_'):
                grid_flat_some = self._get_grid_default(raster_image, x, y, name)
            else:
                grid_flat_some = self._get_grid_tag(raster_image, x, y, name)

            geometric_field = self._make_geometric_field(grid_flat, grid_flat_some, x, y)
            geometric_fields.append(geometric_field)

        return np.stack(geometric_fields, axis=-1)

    @staticmethod
    def _add_default_boundaries(names_boundary):
        names_default_boundary = ['default_left', 'default_bottom', 'default_right', 'default_top']
        names_boundary += names_default_boundary[:]
        return names_boundary

    def _get_default_grid():
        pass

    @staticmethod
    def _get_grid(x, y):
        grid_x, grid_y = np.meshgrid(x, y)
        grid_flat = np.hstack([grid_x.flatten()[:, None], grid_y.flatten()[:, None]])
        return grid_flat

    def _get_grid_tag(self, raster_image, x, y, name):
        tag = self.element_to_tag[name]
        grid_x, grid_y = np.meshgrid(x, y)

        cond = (raster_image==tag)
        grid_x = grid_x[cond]
        grid_y = grid_y[cond]

        return np.hstack([grid_x.flatten()[:, None], grid_y.flatten()[:, None]])

    def _get_grid_default(self, raster_image, x, y, name: str):
        grid_x, grid_y = np.meshgrid(x, y)

        if name.endswith('left'):     grid_x, grid_y = grid_x[0, :], grid_y[0, :]
        elif name.endswith('bottom'): grid_x, grid_y = grid_x[:, 0], grid_y[:, 0]
        elif name.endswith('right'):  grid_x, grid_y = grid_x[-1, :], grid_y[-1, :]
        elif name.endswith('top'):    grid_x, grid_y = grid_x[:, -1], grid_y[:, -1]

        return np.hstack([grid_x.flatten()[:, None], grid_y.flatten()[:, None]])

    def _dist_radial(self, x):
        return np.exp(-self.scaling_factor * x/(x.max()+1e-8))

    def _make_geometric_field(self, grid_flat, grid_flat_some, x, y):
        if self.use_gpu:
            dist_point_to_boundary = eucl_opt(grid_flat, grid_flat_some)
        else:
            dist_point_to_boundary = cdist(grid_flat, grid_flat_some)

        dist_point_to_boundary = np.min(dist_point_to_boundary, axis=1)
        geometric_field = self._dist_radial(dist_point_to_boundary)
        return geometric_field.reshape(len(x), len(y))