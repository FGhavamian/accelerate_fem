# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/notebooks/02_preprocess.ipynb (unless otherwise specified).

__all__ = ['VTUContent', 'read_vtu_files', 'make_grid', 'compute_tri3_shape_function_at', 'find_grids_in_each_element',
           'interpolate']

# Cell
import os

import numpy as np
import meshio
from scipy.spatial import Delaunay

# Cell
class VTUContent:
    def __init__(self, coords, connectivity_quad, field):
        coords = coords[:, :2]
        connectivity = self._quad_to_tri(connectivity_quad)

        self.mesh = self._make_delaunay_mesh(coords, connectivity)
        self.field = field

    def _quad_to_tri(self, connectivity_quad):
        connectivity = []
        for element_nodes in connectivity_quad:
            triangle1_nodes = element_nodes[[0, 1, 2]]
            triangle2_nodes = element_nodes[[0, 2, 3]]

            connectivity.append(triangle1_nodes)
            connectivity.append(triangle2_nodes)

        return np.array(connectivity)

    def _make_delaunay_mesh(self, coords, connectivity):
        mesh = Delaunay(coords)
        mesh.simplices = connectivity.astype(np.int32)
        return mesh

# Cell
def read_vtu_files(paths, field_name):
    data = []
    for path in paths:
        mesh_meshio = meshio.read(path)
        data.append(
            VTUContent(
                mesh_meshio.points,
                mesh_meshio.cells[0].data,
                mesh_meshio.point_data[field_name]
            )
        )
    return data

# Cell
def make_grid(box_coords, grid_size):
    xmin = box_coords[0][0]
    xmax = box_coords[1][0]
    ymin = box_coords[0][1]
    ymax = box_coords[1][1]

    x = np.linspace(xmin, xmax, int((xmax-xmin)/grid_size), dtype=np.float32)
    y = np.linspace(ymin, ymax, int((ymax-ymin)/grid_size), dtype=np.float32)

    grid_x, grid_y = np.meshgrid(x, y)
    grid_flat = np.hstack([grid_x.flatten()[:, None], grid_y.flatten()[:, None]])

    return grid_x, grid_y, grid_flat

# Cell
def compute_tri3_shape_function_at(coord, el_coords):
    x1 = el_coords[0][0]; y1 = el_coords[0][1]
    x2 = el_coords[1][0]; y2 = el_coords[1][1]
    x3 = el_coords[2][0]; y3 = el_coords[2][1]

    a0 = x1; b0 = y1
    a1 = x2 - x1; b1 = y2 - y1
    a2 = x3 - x1; b2 = y3 - y1

    xhat = coord[0]; yhat = coord[1]

    etahat = (a1 * yhat - b1 * xhat + b1 * a0 - a1 * b0) / (a1 * b2 - a2 * b1 + 1e-8)
    xihat = (xhat - a0 - a2 * etahat) / (a1 + 1e-8)

    n1 = 1 - xihat - etahat
    n2 = xihat
    n3 = etahat
    return np.array([n1, n2, n3])

# Cell
def find_grids_in_each_element(mesh, grid_flat):
    grid_point_to_element = mesh.find_simplex(grid_flat, bruteforce=True, tol=1e-1)
    element_to_grid_points = [None for e in range(len(mesh.simplices))]

    for eid in range(len(element_to_grid_points)):
        element_to_grid_points[eid] = np.where(grid_point_to_element == eid)[0]

    return element_to_grid_points

# Cell
def interpolate(data_nodal, grid_flat, grid_dim):
    element_to_grid_points = find_grids_in_each_element(data_nodal.mesh, grid_flat)

    field_grid = np.zeros([grid_flat.shape[0], 1])

    for element, grid_points_in_element in enumerate(element_to_grid_points):
        element_nodes = data_nodal.mesh.simplices[element]
        element_coords = data_nodal.mesh.points[element_nodes]
        field_at_element_nodes = data_nodal.field[element_nodes]

        for grid_point in grid_points_in_element:
            grid_coord = grid_flat[grid_point]
            n = compute_tri3_shape_function_at(grid_coord, element_coords)
            f = n.dot(field_at_element_nodes)

            field_grid[grid_point] = f

    field_grid = field_grid.reshape(*grid_dim)

    return field_grid